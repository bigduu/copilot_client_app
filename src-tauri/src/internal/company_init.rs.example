//! Company Initialization Example
//!
//! This file shows how to implement the company-specific initialization logic.
//! In the company environment, rename this file to `company_init.rs` and implement your logic.

use std::sync::Arc;
use tauri::Runtime;

use super::{InternalContext, InternalConfig};
use crate::tools::{Tool, Category, Parameter, ToolType};
use anyhow::Result;
use async_trait::async_trait;

/// Initialize company-specific functionality
/// 
/// This function is called when COMPANY_INTERNAL=true and provides access to the full context.
pub fn init<R: Runtime>(context: InternalContext<R>) -> Result<(), Box<dyn std::error::Error>> {
    log::info!("Initializing company-specific functionality...");
    
    // Register internal tools with parameters
    register_internal_tools(&context)?;
    
    // Register internal categories with parameters
    register_internal_categories(&context)?;
    
    // Setup internal services
    setup_internal_services(&context)?;
    
    log::info!("Company initialization completed successfully");
    Ok(())
}

/// Register internal tools with the context
fn register_internal_tools<R: Runtime>(context: &InternalContext<R>) -> Result<(), Box<dyn std::error::Error>> {
    // Register Bitbucket tool with configuration
    context.tool_registry.register_tool(
        "bitbucket",
        Box::new(|config: &InternalConfig| {
            Arc::new(CompanyBitbucketTool::new(config.bitbucket_base_url.clone()))
        })
    );
    
    // Register Confluence tool with configuration
    context.tool_registry.register_tool(
        "confluence", 
        Box::new(|config: &InternalConfig| {
            Arc::new(CompanyConfluenceTool::new(config.confluence_base_url.clone()))
        })
    );
    
    log::info!("Registered {} internal tools", context.tool_registry.list_tools().len());
    Ok(())
}

/// Register internal categories with the context
fn register_internal_categories<R: Runtime>(context: &InternalContext<R>) -> Result<(), Box<dyn std::error::Error>> {
    // Register company tools category
    context.category_registry.register_category(
        "company_tools",
        Box::new(|config: &InternalConfig| {
            Box::new(CompanyToolsCategory::new(config.clone()))
        })
    );
    
    log::info!("Registered {} internal categories", context.category_registry.list_categories().len());
    Ok(())
}

/// Setup internal services with the context
fn setup_internal_services<R: Runtime>(context: &InternalContext<R>) -> Result<(), Box<dyn std::error::Error>> {
    // Setup proxy configuration
    if let Some(proxy_config) = &context.config.proxy_config {
        log::info!("Setting up proxy configuration: {:?}", proxy_config);
        // TODO: Apply proxy configuration to HTTP clients
    }
    
    // Setup authentication service
    if let Some(auth_config) = &context.config.auth_config {
        log::info!("Setting up authentication service");
        // TODO: Initialize authentication service
    }
    
    // Register services with Tauri state management
    unsafe {
        let app = context.app();
        // app.manage(SomeInternalService::new());
    }
    
    Ok(())
}

// Example internal tool implementations with parameters

/// Company Bitbucket tool with configurable base URL
#[derive(Debug)]
pub struct CompanyBitbucketTool {
    base_url: String,
}

impl CompanyBitbucketTool {
    pub fn new(base_url: String) -> Self {
        Self { base_url }
    }
}

#[async_trait]
impl Tool for CompanyBitbucketTool {
    fn name(&self) -> String {
        "bitbucket".to_string()
    }
    
    fn description(&self) -> String {
        format!("Access company Bitbucket at {}", self.base_url)
    }
    
    fn parameters(&self) -> Vec<Parameter> {
        vec![
            Parameter {
                name: "action".to_string(),
                description: "Action to perform".to_string(),
                required: true,
                value: "".to_string(),
            }
        ]
    }
    
    fn tool_type(&self) -> ToolType {
        ToolType::AIParameterParsing
    }
    
    fn required_approval(&self) -> bool {
        false
    }
    
    async fn execute(&self, parameters: Vec<Parameter>) -> Result<String> {
        // Implementation using self.base_url
        Ok(format!("Bitbucket tool executed with base URL: {}", self.base_url))
    }
}

/// Company Confluence tool with configurable base URL
#[derive(Debug)]
pub struct CompanyConfluenceTool {
    base_url: String,
}

impl CompanyConfluenceTool {
    pub fn new(base_url: String) -> Self {
        Self { base_url }
    }
}

#[async_trait]
impl Tool for CompanyConfluenceTool {
    fn name(&self) -> String {
        "confluence".to_string()
    }
    
    fn description(&self) -> String {
        format!("Access company Confluence at {}", self.base_url)
    }
    
    fn parameters(&self) -> Vec<Parameter> {
        vec![
            Parameter {
                name: "action".to_string(),
                description: "Action to perform".to_string(),
                required: true,
                value: "".to_string(),
            }
        ]
    }
    
    fn tool_type(&self) -> ToolType {
        ToolType::AIParameterParsing
    }
    
    fn required_approval(&self) -> bool {
        false
    }
    
    async fn execute(&self, parameters: Vec<Parameter>) -> Result<String> {
        // Implementation using self.base_url
        Ok(format!("Confluence tool executed with base URL: {}", self.base_url))
    }
}

/// Company tools category with configuration
#[derive(Debug)]
pub struct CompanyToolsCategory {
    config: InternalConfig,
}

impl CompanyToolsCategory {
    pub fn new(config: InternalConfig) -> Self {
        Self { config }
    }
}

impl Category for CompanyToolsCategory {
    fn id(&self) -> String {
        "company_tools".to_string()
    }
    
    fn name(&self) -> String {
        "company_tools".to_string()
    }
    
    fn display_name(&self) -> String {
        "Company Tools".to_string()
    }
    
    fn description(&self) -> String {
        "Company-specific tools and services".to_string()
    }
    
    fn system_prompt(&self) -> String {
        "You have access to company-specific tools for Bitbucket and Confluence.".to_string()
    }
    
    fn icon(&self) -> String {
        "🏢".to_string()
    }
    
    fn frontend_icon(&self) -> String {
        "BankOutlined".to_string()
    }
    
    fn color(&self) -> String {
        "#1890ff".to_string()
    }
    
    fn strict_tools_mode(&self) -> bool {
        false
    }
    
    fn priority(&self) -> i32 {
        100
    }
    
    fn enable(&self) -> bool {
        self.config.company_internal_enabled
    }
    
    fn category_type(&self) -> crate::tools::tool_types::CategoryId {
        crate::tools::tool_types::CategoryId::GeneralAssistant
    }
    
    fn required_tools(&self) -> &'static [&'static str] {
        &["bitbucket", "confluence"]
    }
}
