import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { App as AntApp } from "antd";
import { useAppStore } from "../store";
import { useMachine } from "@xstate/react";
import { chatMachine, ChatMachineEvent } from "../core/chatInteractionMachine";
import {
  ChatItem,
  UserSystemPrompt,
  UserMessage,
  AssistantTextMessage,
  MessageImage,
  Message,
} from "../types/chat";
import { ImageFile } from "../utils/imageUtils";
import { SystemPromptService } from "../services";
import { transformMessageDTOToMessage } from "../utils/messageTransformers";

/**
 * Unified hook for managing all chat-related state and interactions.
 * This hook is the single source of truth for chat management in the UI.
 *
 * Uses Signal-Pull SSE architecture for backend-driven streaming.
 */
export const useChatManager = () => {
  const { modal, message: appMessage } = AntApp.useApp();

  // --- STATE SELECTION FROM ZUSTAND ---
  const chats = useAppStore((state) => state.chats);
  const currentChatId = useAppStore((state) => state.currentChatId);
  const addChat = useAppStore((state) => state.addChat);
  const setMessages = useAppStore((state) => state.setMessages);
  const addMessage = useAppStore((state) => state.addMessage);
  const selectChat = useAppStore((state) => state.selectChat);
  const deleteChat = useAppStore((state) => state.deleteChat);
  const deleteChats = useAppStore((state) => state.deleteChats);
  const deleteMessage = useAppStore((state) => state.deleteMessage);
  const updateChat = useAppStore((state) => state.updateChat);
  const pinChat = useAppStore((state) => state.pinChat);
  const unpinChat = useAppStore((state) => state.unpinChat);
  const loadChats = useAppStore((state) => state.loadChats);
  const autoGenerateTitles = useAppStore((state) => state.autoGenerateTitles);
  const setAutoGenerateTitlesPreference = useAppStore(
    (state) => state.setAutoGenerateTitlesPreference
  );
  const isUpdatingAutoTitlePreference = useAppStore(
    (state) => state.isUpdatingAutoTitlePreference
  );
  const updateMessageContent = useAppStore(
    (state) => state.updateMessageContent
  );
  const lastSelectedPromptId = useAppStore(
    (state) => state.lastSelectedPromptId
  );
  const systemPrompts = useAppStore((state) => state.systemPrompts);

  // --- DERIVED STATE ---
  const currentChat = useMemo(
    () => chats.find((chat) => chat.id === currentChatId) || null,
    [chats, currentChatId]
  );
  const baseMessages = useMemo(
    () => currentChat?.messages || [],
    [currentChat]
  );
  const pinnedChats = useMemo(
    () => chats.filter((chat) => chat.pinned),
    [chats]
  );
  const unpinnedChats = useMemo(
    () => chats.filter((chat) => !chat.pinned),
    [chats]
  );
  const chatCount = chats.length;

  const autoTitleGeneratedRef = useRef<Set<string>>(new Set());
  const titleGenerationInFlightRef = useRef<Set<string>>(new Set());
  const [titleGenerationState, setTitleGenerationState] = useState<
    Record<string, { status: "idle" | "loading" | "error"; error?: string }>
  >({});

  // SSE subscription cleanup for Signal-Pull architecture
  const sseUnsubscribeRef = useRef<(() => void) | null>(null);
  const currentSequenceRef = useRef<number>(0);
  const currentMessageIdRef = useRef<string | null>(null);

  const isDefaultTitle = useCallback((title: string | undefined | null) => {
    if (!title) return true;
    const normalized = title.trim().toLowerCase();
    if (normalized.length === 0) return true;
    if (normalized === "new chat" || normalized === "main") return true;
    return normalized.startsWith("new chat -");
  }, []);

  const generateChatTitle = useCallback(
    async (chatId: string, options?: { force?: boolean }) => {
      const state = useAppStore.getState();
      const chat = state.chats.find((c) => c.id === chatId);
      if (!chat) {
        return;
      }

      const userAssistantMessages = chat.messages.filter((msg) => {
        if (msg.role === "user") return true;
        if (msg.role === "assistant" && "type" in msg) {
          return (msg as AssistantTextMessage).type === "text";
        }
        return false;
      });

      const isAuto = !options?.force;
      if (isAuto && !autoGenerateTitles) {
        return;
      }
      const MAX_AUTO_MESSAGES = 6;

      if (isAuto) {
        if (titleGenerationInFlightRef.current.has(chatId)) {
          return;
        }
        if (autoTitleGeneratedRef.current.has(chatId)) {
          return;
        }
        if (!isDefaultTitle(chat.title)) {
          return;
        }
        if (userAssistantMessages.length === 0) {
          return;
        }
        if (userAssistantMessages.length > MAX_AUTO_MESSAGES) {
          return;
        }
      }

      titleGenerationInFlightRef.current.add(chatId);
      setTitleGenerationState((prev) => ({
        ...prev,
        [chatId]: { status: "loading" },
      }));

      try {
        const { BackendContextService } = await import(
          "../services/BackendContextService"
        );
        const backendService = new BackendContextService();
        const response = await backendService.generateTitle(chatId, {
          maxLength: 60,
          messageLimit: 6,
        });
        const candidate = response.title?.trim();
        if (!candidate) {
          throw new Error("生成的标题为空");
        }

        // Backend now saves the title, so we sync from backend
        // Fetch the updated context to get the saved title
        const context = await backendService.getContext(chatId);
        const savedTitle = context.title || candidate;

        console.log(
          `[useChatManager] Updating chat ${chatId} title to: "${savedTitle}"`
        );
        updateChat(chatId, { title: savedTitle });
        if (!isAuto || savedTitle.toLowerCase() !== "new chat") {
          autoTitleGeneratedRef.current.add(chatId);
        }

        setTitleGenerationState((prev) => ({
          ...prev,
          [chatId]: { status: "idle" },
        }));

        if (options?.force) {
          appMessage?.success?.("聊天标题已更新");
        }
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "生成标题失败";
        setTitleGenerationState((prev) => ({
          ...prev,
          [chatId]: { status: "error", error: errorMessage },
        }));
        if (options?.force) {
          appMessage?.error?.(errorMessage);
        } else {
          appMessage?.warning?.(errorMessage);
        }
      } finally {
        titleGenerationInFlightRef.current.delete(chatId);
      }
    },
    [appMessage, autoGenerateTitles, isDefaultTitle, updateChat]
  );

  // --- LOCAL UI STATE FOR STREAMING ---
  const [streamingText, setStreamingText] = useState("");
  const [streamingMessageId, setStreamingMessageId] = useState<string | null>(
    null
  );

  // --- AGENT APPROVAL STATE ---
  const [pendingAgentApproval, setPendingAgentApproval] = useState<{
    request_id: string;
    session_id: string;
    tool: string;
    tool_description: string;
    parameters: Record<string, any>;
  } | null>(null);

  // --- CHAT INTERACTION STATE MACHINE ---
  // Provide the concrete implementations for the actions defined in the machine
  const providedChatMachine = useMemo(() => {
    return chatMachine.provide({
      actions: {
        forwardChunkToUI: ({ event }: { event: ChatMachineEvent }) => {
          if (event.type === "CHUNK_RECEIVED") {
            setStreamingText((prev) => prev + event.payload.chunk);
          }
        },
        finalizeStreamingMessage: async ({
          event,
        }: {
          event: ChatMachineEvent;
        }) => {
          const { currentChatId: chatId } = useAppStore.getState();
          if (
            event.type === "STREAM_COMPLETE_TEXT" &&
            streamingMessageId &&
            chatId
          ) {
            await updateMessageContent(
              chatId,
              streamingMessageId,
              event.payload.finalContent
            );
            // Reset local streaming UI state
            setStreamingMessageId(null);
            setStreamingText("");
          }
        },
      },
    });
  }, []); // ✅ 移除依赖项，只在组件挂载时初始化一次

  const [state, send] = useMachine(providedChatMachine);
  const prevStateRef = useRef(state);
  const prevChatIdRef = useRef<string | null>(null);

  // --- FINAL MESSAGES FOR UI ---
  // This combines the persisted messages from Zustand with the live streaming text
  const currentMessages = useMemo(() => {
    if (!streamingMessageId) {
      return baseMessages;
    }
    // Ensure the streaming message placeholder is part of the list
    const messageExists = baseMessages.some(
      (msg) => msg.id === streamingMessageId
    );
    const list = messageExists
      ? baseMessages
      : [
          ...baseMessages,
          {
            id: streamingMessageId,
            role: "assistant",
            type: "text",
            content: "",
            createdAt: new Date().toISOString(),
          } as AssistantTextMessage,
        ];

    return list.map((msg) =>
      msg.id === streamingMessageId ? { ...msg, content: streamingText } : msg
    );
  }, [baseMessages, streamingMessageId, streamingText]);

  // Reset state machine when chat changes
  useEffect(() => {
    if (prevChatIdRef.current && prevChatIdRef.current !== currentChatId) {
      send({ type: "CANCEL" });
      setStreamingMessageId(null);
      setStreamingText("");
    }
    prevChatIdRef.current = currentChatId;
  }, [currentChatId, send]);

  // Handle side-effects based on state transitions (NOT events)
  useEffect(() => {
    const { currentChatId: chatId } = useAppStore.getState();
    if (!chatId) return;

    const prevState = prevStateRef.current;

    if (state.value === prevState.value) {
      return;
    }

    console.log(
      `[ChatManager] State changed from ${JSON.stringify(
        prevState.value
      )} to ${JSON.stringify(state.value)}`
    );

    // --- Handle entering THINKING state ---
    if (state.matches("THINKING") && !prevState.matches("THINKING")) {
      const newStreamingMessage: AssistantTextMessage = {
        id: crypto.randomUUID(),
        role: "assistant",
        type: "text",
        content: "",
        createdAt: new Date().toISOString(),
      };
      addMessage(chatId, newStreamingMessage);
      setStreamingMessageId(newStreamingMessage.id);
      setStreamingText("");
    }

    // --- Sync message list on other state changes ---
    // This ensures that tool calls and other non-streaming updates are reflected.
    if (state.context.messages.length !== prevState.context.messages.length) {
      setMessages(chatId, state.context.messages);
    }

    prevStateRef.current = state;
  }, [state, addMessage, setMessages]);

  // --- SSE CLEANUP ---
  // Cleanup SSE subscription when component unmounts or chat changes
  useEffect(() => {
    return () => {
      if (sseUnsubscribeRef.current) {
        console.log("[ChatManager] Cleaning up SSE subscription");
        sseUnsubscribeRef.current();
        sseUnsubscribeRef.current = null;
      }
    };
  }, [currentChatId]); // Cleanup when chat changes

  // --- ACTIONS ---

  const sendMessage = useCallback(
    async (content: string, images?: ImageFile[]) => {
      if (!currentChat) {
        modal.info({
          title: "No Active Chat",
          content: "Please create or select a chat before sending a message.",
        });
        return;
      }
      console.log(
        "[ChatManager] sendMessage: currentChat.config on entry:",
        currentChat.config
      );
      const chatId = currentChat.id;

      // ✅ Signal-Pull SSE architecture
      console.log("[ChatManager] Using Signal-Pull SSE architecture");

      const processedContent = content;
      const messageImages: MessageImage[] =
        images?.map((img) => ({
          id: img.id,
          base64: img.base64,
          name: img.name,
          size: img.size,
          type: img.type,
        })) || [];

      const userMessage: UserMessage = {
        role: "user",
        content: processedContent,
        id: crypto.randomUUID(),
        createdAt: new Date().toISOString(),
        images: messageImages,
      };

      // Add user message locally for optimistic UI update
      await addMessage(chatId, userMessage);

      try {
        const { backendContextService } = await import(
          "../services/BackendContextService"
        );

        // Create temporary assistant message for streaming
        const assistantMessageId = crypto.randomUUID();
        const assistantMessage: AssistantTextMessage = {
          id: assistantMessageId,
          role: "assistant",
          type: "text",
          content: "",
          createdAt: new Date().toISOString(),
        };

        // Add empty assistant message to show streaming indicator
        await addMessage(chatId, assistantMessage);

        // Reset sequence tracking
        currentSequenceRef.current = 0;
        currentMessageIdRef.current = assistantMessageId;
        let accumulatedContent = "";

        // Queue to ensure sequential processing of content_delta events
        let pullQueue = Promise.resolve();

        console.log(
          `[ChatManager] Starting Signal-Pull SSE for chat ${chatId}`
        );

        // 1. Subscribe to SSE events FIRST (before sending message)
        const unsubscribe = backendContextService.subscribeToContextEvents(
          chatId,
          async (event) => {
            console.log(`[ChatManager] SSE event received:`, event.type);

            switch (event.type) {
              case "message_created":
                console.log(
                  `[ChatManager] MessageCreated event: message_id=${event.message_id}, role=${event.role}`
                );
                // Reset sequence tracking for new message
                currentSequenceRef.current = 0;
                accumulatedContent = "";
                break;

              case "content_delta":
                // Queue this pull operation to ensure sequential processing
                pullQueue = pullQueue.then(async () => {
                  try {
                    const fromSequence = currentSequenceRef.current;
                    console.log(
                      `[ChatManager] ContentDelta: event.current_sequence=${event.current_sequence}, pulling from ${fromSequence}`
                    );

                    // Pull new chunks from current sequence
                    const contentResponse =
                      await backendContextService.getMessageContent(
                        event.context_id,
                        event.message_id,
                        fromSequence
                      );

                    console.log(
                      `[ChatManager] Pulled ${contentResponse.chunks.length} chunks, new current_sequence=${contentResponse.current_sequence}`
                    );

                    // Accumulate content from NEW chunks only
                    if (
                      contentResponse.chunks &&
                      contentResponse.chunks.length > 0
                    ) {
                      for (const chunk of contentResponse.chunks) {
                        accumulatedContent += chunk.delta;
                      }

                      console.log(
                        `[ChatManager] Accumulated content length: ${accumulatedContent.length}`
                      );

                      // Update message in UI
                      const updatedAssistantMessage: AssistantTextMessage = {
                        ...assistantMessage,
                        content: accumulatedContent,
                      };

                      const { chats } = useAppStore.getState();
                      const currentChat = chats.find((c) => c.id === chatId);
                      if (currentChat) {
                        const updatedMessages = currentChat.messages.map(
                          (msg) =>
                            msg.id === assistantMessageId
                              ? updatedAssistantMessage
                              : msg
                        );
                        setMessages(chatId, updatedMessages);
                      }
                    }

                    // Update sequence tracking AFTER processing
                    currentSequenceRef.current =
                      contentResponse.current_sequence;
                  } catch (error) {
                    console.error(
                      "[ChatManager] Failed to pull content:",
                      error
                    );
                    appMessage.error("Failed to receive message content");
                  }
                });
                break;

              case "message_completed":
                console.log(
                  `[ChatManager] Message completed, fetching final state`
                );

                // Cleanup SSE subscription
                if (sseUnsubscribeRef.current) {
                  sseUnsubscribeRef.current();
                  sseUnsubscribeRef.current = null;
                }

                // Fetch final messages from backend to ensure consistency
                try {
                  const messages =
                    await backendContextService.getMessages(chatId);
                  const allMessages: Message[] = messages.messages
                    .map((msg) => transformMessageDTOToMessage(msg))
                    .filter(Boolean) as Message[];

                  setMessages(chatId, allMessages);
                  console.log(
                    `[ChatManager] Final messages synced: ${allMessages.length} messages`
                  );
                } catch (error) {
                  console.error(
                    "[ChatManager] Failed to fetch final messages:",
                    error
                  );
                }
                break;

              case "state_changed":
                console.log(
                  `[ChatManager] Backend state changed: ${event.new_state}`
                );
                // Could update UI state indicator here if needed
                break;

              case "title_updated":
                console.log(
                  `[ChatManager] Title updated to: "${event.title}"`
                );
                // Update the chat title in the UI immediately
                updateChat(chatId, { title: event.title });
                break;

              case "heartbeat":
                // Keep-alive, no action needed
                break;

              default:
                console.warn(
                  "[ChatManager] Unknown SSE event type:",
                  (event as any).type
                );
            }
          },
          (error) => {
            console.error("[ChatManager] SSE error:", error);
            appMessage.error("Connection error. Please try again.");

            // Cleanup on error
            if (sseUnsubscribeRef.current) {
              sseUnsubscribeRef.current();
              sseUnsubscribeRef.current = null;
            }
          }
        );

        // Store unsubscribe function for cleanup
        sseUnsubscribeRef.current = unsubscribe;

        // 2. Send message to backend AFTER subscribing to SSE
        try {
          await backendContextService.sendMessage(chatId, processedContent);
          console.log(`[ChatManager] Message sent successfully`);
        } catch (error) {
          console.error("[ChatManager] Failed to send message:", error);
          appMessage.error("Failed to send message. Please try again.");

          // Cleanup SSE subscription on error
          if (sseUnsubscribeRef.current) {
            sseUnsubscribeRef.current();
            sseUnsubscribeRef.current = null;
          }
        }
      } catch (error) {
        console.error("[ChatManager] Failed to setup SSE:", error);
        appMessage.error("Failed to setup connection. Please try again.");
      }
    },
    [
      currentChat,
      addMessage,
      send,
      modal,
      baseMessages,
      systemPrompts,
      setMessages,
      generateChatTitle,
    ]
  );

  const retryLastMessage = useCallback(async () => {
    if (!currentChat) return;
    const chatId = currentChat.id;
    const history = [...baseMessages];

    if (history.length === 0) return;

    const lastMessage = history[history.length - 1];
    let messagesToRetry = history;

    if (lastMessage?.role === "assistant") {
      deleteMessage(chatId, lastMessage.id);
      messagesToRetry = history.slice(0, -1);
    }

    if (messagesToRetry.length > 0) {
      const updatedChat: ChatItem = {
        ...currentChat,
        messages: messagesToRetry,
      };
      send({
        type: "USER_SUBMITS",
        payload: {
          messages: messagesToRetry,
          chat: updatedChat,
          systemPrompts,
        },
      });
    }
  }, [currentChat, baseMessages, deleteMessage, send, systemPrompts]);

  const createNewChat = useCallback(
    async (title?: string, options?: Partial<Omit<ChatItem, "id">>) => {
      const selectedPrompt = systemPrompts.find(
        (p) => p.id === lastSelectedPromptId
      );

      // Use actual prompt ID or undefined (no hardcoded defaults)
      const systemPromptId =
        selectedPrompt?.id ||
        (systemPrompts.length > 0
          ? systemPrompts.find((p) => p.id === "general_assistant")?.id ||
            systemPrompts[0].id
          : "");

      const newChatData: Omit<ChatItem, "id"> = {
        title: title || "New Chat",
        createdAt: Date.now(),
        messages: [],
        config: {
          systemPromptId,
          baseSystemPrompt:
            selectedPrompt?.content ||
            (systemPrompts.length > 0
              ? systemPrompts.find((p) => p.id === "general_assistant")
                  ?.content || systemPrompts[0].content
              : "You are a helpful assistant."),
          toolCategory: "general",
          lastUsedEnhancedPrompt: null,
        },
        currentInteraction: null,
        ...options,
      };
      await addChat(newChatData);
    },
    [addChat, lastSelectedPromptId, systemPrompts]
  );

  const createChatWithSystemPrompt = useCallback(
    async (prompt: UserSystemPrompt) => {
      console.log(
        "[ChatManager] createChatWithSystemPrompt started with prompt:",
        prompt
      );
      const systemPromptService = SystemPromptService.getInstance();
      const enhancedPrompt = await systemPromptService.getEnhancedSystemPrompt(
        prompt.id
      );

      const newChatData: Omit<ChatItem, "id"> = {
        title: `New Chat - ${prompt.name}`,
        createdAt: Date.now(),
        messages: [
          {
            id: "system-prompt",
            role: "system",
            content: enhancedPrompt,
            createdAt: new Date().toISOString(),
          },
        ],
        config: {
          systemPromptId: prompt.id,
          baseSystemPrompt: prompt.content, // Store the original prompt content
          toolCategory: "dynamic", // A new category to signify dynamic tool usage
          lastUsedEnhancedPrompt: enhancedPrompt,
        },
        currentInteraction: null,
      };
      console.log(
        "[ChatManager] Calling addChat with newChatData.config:",
        newChatData.config
      );
      await addChat(newChatData);
    },
    [addChat]
  );

  const toggleChatPin = useCallback(
    (chatId: string) => {
      const chat = chats.find((c) => c.id === chatId);
      if (chat) {
        chat.pinned ? unpinChat(chatId) : pinChat(chatId);
      }
    },
    [chats, pinChat, unpinChat]
  );

  const updateChatTitle = useCallback(
    (chatId: string, newTitle: string) => {
      updateChat(chatId, { title: newTitle });
    },
    [updateChat]
  );

  const deleteEmptyChats = useCallback(() => {
    const emptyChatIds = chats
      .filter((chat) => !chat.pinned && chat.messages.length === 0)
      .map((chat) => chat.id);
    if (emptyChatIds.length > 0) {
      deleteChats(emptyChatIds);
    }
  }, [chats, deleteChats]);

  const deleteAllUnpinnedChats = useCallback(() => {
    const unpinnedChatsIds = unpinnedChats.map((chat) => chat.id);
    if (unpinnedChatsIds.length > 0) {
      deleteChats(unpinnedChatsIds);
    }
  }, [unpinnedChats, deleteChats]);

  return {
    // State
    chats,
    currentChatId,
    currentChat,
    currentMessages,
    pinnedChats,
    unpinnedChats,
    chatCount,
    interactionState: state,
    pendingAgentApproval,
    setPendingAgentApproval,
    titleGenerationState,
    autoGenerateTitles,
    isUpdatingAutoTitlePreference,

    // Actions
    addMessage,
    deleteMessage,
    selectChat,
    deleteChat,
    deleteChats,
    pinChat,
    unpinChat,
    updateChat,
    loadChats,
    createNewChat,
    createChatWithSystemPrompt,
    toggleChatPin,
    updateChatTitle,
    deleteEmptyChats,
    deleteAllUnpinnedChats,
    sendMessage,
    retryLastMessage,
    generateChatTitle,
    setAutoGenerateTitlesPreference,

    // Machine sender
    send,
  };
};
